OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:18:29.223-05:00' ],		#prior : OmReference [ 'Pharo10-SNAPSHOT-64bit-2314c3f.copyqej1bryxuxptabiyt1fw8', '27' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\t\t\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll.]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\rTranscript show: \'Here\'.\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:17',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll.]\r\t\tifFalse:[\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\rTranscript show: \'Here\'.\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:18',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:22:10.264-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll.]\r\t\tifFalse:[\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\rTranscript show: \'Here\'.\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:18',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\rTranscript show: \'Here\'.\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:22',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:22:21.067-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\rTranscript show: \'Here\'.\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:22',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:22',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:22:41.236-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\asher\\Documents\\Pharo\\images\\Assignment\\Assignment.image'	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:23:28.914-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:22',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:23',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:23:48.896-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:23',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:23',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:24:09.793-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:23',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:24',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:24:23.726-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:24',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:24',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:25:26.631-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:24',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\rTranscript show: warchest.\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:25',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:25:40.86-05:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\rTranscript show: warchest.\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:25',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\rTranscript show: warchest; cr.\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:25',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:28:27.612-05:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\rTranscript show: warchest; cr.\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:25',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\rTranscript show: warchest; cr.\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:28',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:28:40.279-05:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\rTranscript show: warchest; cr.\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:28',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\rTranscript show: warchest; cr.\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:28',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:29:52.827-05:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\rTranscript show: warchest; cr.\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:28',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\rTranscript show: p1; cr.\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:29',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:30:38.665-05:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\rTranscript show: p1; cr.\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:29',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:30',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:31:16.172-05:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 00:14',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 09:31',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:31:26.714-05:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 09:31',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1;cr.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 09:31',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:33:16.92-05:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1;cr.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 09:31',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer2;cr.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 09:33',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:34:22.137-05:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer2;cr.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 09:33',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 09:34',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:39:23.671-05:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:30',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:39',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T09:40:02.939-05:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:39',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:40',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T10:39:33.715-05:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 09:34',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: warchest;cr.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 10:39',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T10:40:23.499-05:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: warchest;cr.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 10:39',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\tTranscript show: p1First;cr.\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: p1First;cr;cr.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 10:40',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T10:41:05.399-05:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\asher\\Documents\\Pharo\\images\\Assignment\\Assignment.image'	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T10:41:55.828-05:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\tTranscript show: p1First;cr.\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: p1First;cr;cr.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 10:40',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\tTranscript show: p1First;cr.\r\t\t\tTranscript show: p2First;cr;cr.\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 10:41',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T10:42:56.859-05:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 09:40',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) <= 2) | ((p2 size) <= 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 10:42',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T10:45:53.027-05:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\tTranscript show: p1First;cr.\r\t\t\tTranscript show: p2First;cr;cr.\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 10:41',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 10:45',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T10:46:47.888-05:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) <= 2) | ((p2 size) <= 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 10:42',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t\t\r\t\t\t\t\t\tTranscript show: p1First;cr.\r\t\t\t\t\t\tTranscript show: p2First;cr;cr.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 10:46',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T11:04:50.701-05:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t\t\r\t\t\t\t\t\tTranscript show: p1First;cr.\r\t\t\t\t\t\tTranscript show: p2First;cr;cr.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 10:46',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t\t\r\t\t\t\t\t\tTranscript show: p1First;cr.\r\t\t\t\t\t\tTranscript show: p2First.\r\t\t\t\t\t] \r\t\t\t].\r\t].\rTranscript show: \'Out\';cr;cr.\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 11:04',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T11:06:30.836-05:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t\t\r\t\t\t\t\t\tTranscript show: p1First;cr.\r\t\t\t\t\t\tTranscript show: p2First.\r\t\t\t\t\t] \r\t\t\t].\r\t].\rTranscript show: \'Out\';cr;cr.\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 11:04',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"change sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First)] whileTrue:[\r\t\t"Check to see if one of the players will have an empty hand during war"\r\t\t"If so move everything to the warchest"\r\t\t(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. \r\t\t\tp1 removeAll. p2 removeAll. p1First := 14]\r\t\tifFalse:[\r\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\r\t\t\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\t\twarchest add: (p1 first); add: (p2 first).\r\t\t\t\tp1 removeFirst.\r\t\t\t\tp2 removeFirst.\r\t\t\t\t\r\t\t\t\t"Assign to be the third card card comparison"\r\t\t\t\tp1First := p1 first.\r\t\t\t\tp2First := p2 first.\r\t\t\t\t\r\t\t\t\t(p1First ~= p2First) ifTrue:[\r\t\t\t\t\t\twarchest add: p1First; add: p2First. \r\t\t\t\t\t\tp1 removeFirst.\r\t\t\t\t\t\tp2 removeFirst.\r\t\t\t\t\t] \r\t\t\t].\r\t].\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] \r\tifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 11:06',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T11:06:56.321-05:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 10:45',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\tTranscript show: p1First;cr.\r\t\tTranscript show: p2First;cr;cr.\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/23/2023 11:06',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T11:08:41.652-05:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\asher\\Documents\\Pharo\\images\\Assignment\\Assignment.image'	}}