OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-25T09:00:00.813-05:00' ],		#prior : OmReference [ 'Pharo10-SNAPSHOT-64bit-2314c3f.3i61lk3qfvnr4dutdw3lc56co', '21' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/24/2023 22:55',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\t(((p1First < p2First) & (p1First ~= 1)) | (p2First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:00',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-25T09:00:59.905-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\t(((p1First < p2First) & (p1First ~= 1)) | (p2First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:00',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:00',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-25T09:02:08.12-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:00',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:02',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-25T09:02:40.722-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:02',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:02',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-25T09:14:46.408-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:02',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\tTranscript show: playPlayer2;cr.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:14',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-25T09:16:05.096-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\tTranscript show: playPlayer2;cr.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:14',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\tTranscript show: playPlayer2;cr;cr.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:16',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-25T09:16:18.553-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\tTranscript show: playPlayer2;cr;cr.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:16',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\tTranscript show: playPlayer2;cr;cr.\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:16',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-25T09:20:39.323-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\tTranscript show: playPlayer2;cr;cr.\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:16',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\tTranscript show: playPlayer2;cr.\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\tTranscript show: warchest;cr;cr.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:20',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-25T09:24:32.009-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\tTranscript show: playPlayer2;cr.\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\tTranscript show: warchest;cr;cr.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:20',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\tTranscript show: playPlayer1;cr.\r\t\tTranscript show: playPlayer2;cr;cr.\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t"Make sure 1s are the highest number"\r\t\t\t(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[\r\t\t\t\t\tplayPlayer1 addLast: p1First. playPlayer1 addLast: p2First. \r\t\t\t\t\tplayPlayer1 removeFirst. playPlayer2 removeFirst\r\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. \r\t\t\t\t\tplayPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\rTranscript show: winner;cr.\r^winner asArray',			#stamp : 'Anonymous 2/25/2023 09:24',			#package : #Assignment		}	}}