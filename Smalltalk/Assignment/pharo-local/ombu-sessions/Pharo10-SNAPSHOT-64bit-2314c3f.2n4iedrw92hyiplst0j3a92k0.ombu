OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:31:21.417-05:00' ],		#prior : OmReference [ 'Pharo10-SNAPSHOT-64bit-2314c3f.dr7sb19v7zycj443qbd09t84w', '7' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst.]\r\t\tifFalse:[\r\t\t\t((p2First > p1First) | (p2First == 1)) ifTrue:[playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst.]\r\t\t\t]\r\t].\r\r(playPlayer1 isEmpty) ifTrue:[^playPlayer2] ifFalse:[^playPlayer1]',			#stamp : 'Anonymous 2/21/2023 20:28',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\tifFalse:[\r\t\t\t((p2First > p1First) | (p2First == 1)) ifTrue:[playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst]\r\t\t\t]\r\t].\r\r(playPlayer1 isEmpty) ifTrue:[^playPlayer2] ifFalse:[^playPlayer1]',			#stamp : 'Anonymous 2/21/2023 20:31',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:31:26.712-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\asher\\Documents\\Pharo\\images\\Assignment\\Assignment.image'	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:34:23.24-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\tifFalse:[\r\t\t\t((p2First > p1First) | (p2First == 1)) ifTrue:[playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst]\r\t\t\t]\r\t].\r\r(playPlayer1 isEmpty) ifTrue:[^playPlayer2] ifFalse:[^playPlayer1]',			#stamp : 'Anonymous 2/21/2023 20:31',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\tifFalse:[\r\t\t\t((p2First > p1First) | (p2First == 1)) ifTrue:[playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst]\r\t\t\t]\r\t].\r\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 20:34',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:35:56.231-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleUnclassifiedMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUnclassifiedMethodsRuleV1FalsePositive\r\t^ #()',			#stamp : 'Anonymous 2/21/2023 20:35',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:35:59.404-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleUnclassifiedMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUnclassifiedMethodsRuleV1FalsePositive\r\t^ #()',			#stamp : 'Anonymous 2/21/2023 20:35',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleUnclassifiedMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUnclassifiedMethodsRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#War #play #false)) #\'2023-02-21T20:35:56.233-05:00\') )',			#stamp : 'Anonymous 2/21/2023 20:35',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:36:07.228-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleAssignmentInIfTrueRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleAssignmentInIfTrueRuleV1FalsePositive\r\t^ #()',			#stamp : 'Anonymous 2/21/2023 20:36',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:36:08.366-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleAssignmentInIfTrueRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleAssignmentInIfTrueRuleV1FalsePositive\r\t^ #()',			#stamp : 'Anonymous 2/21/2023 20:36',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleAssignmentInIfTrueRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleAssignmentInIfTrueRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#War #play #false)) #\'2023-02-21T20:36:07.23-05:00\') )',			#stamp : 'Anonymous 2/21/2023 20:36',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:40:20.972-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleLongMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleLongMethodsRuleV1FalsePositive\r\t^ #()',			#stamp : 'Anonymous 2/21/2023 20:40',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:40:22.248-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleLongMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleLongMethodsRuleV1FalsePositive\r\t^ #()',			#stamp : 'Anonymous 2/21/2023 20:40',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleLongMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleLongMethodsRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#War #play #false)) #\'2023-02-21T20:40:20.973-05:00\') )',			#stamp : 'Anonymous 2/21/2023 20:40',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:41:21.518-05:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\asher\\Documents\\Pharo\\images\\Assignment\\Assignment.image'	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:42:46.092-05:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\tifFalse:[\r\t\t\t((p2First > p1First) | (p2First == 1)) ifTrue:[playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst]\r\t\t\t]\r\t].\r\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 20:34',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game while until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\tifFalse:[\r\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t]\r\t].\r\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 20:42',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:55:43.674-05:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game while until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\tifFalse:[\r\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t]\r\t].\r\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 20:42',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game while until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t]\r\t].\r\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 20:55',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T20:56:01.478-05:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2',			#stamp : 'Anonymous 2/21/2023 20:56',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T21:39:00.046-05:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game while until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t]\r\t].\r\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 20:55',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t]\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 21:39',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:12:25.769-05:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2',			#stamp : 'Anonymous 2/21/2023 20:56',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r(p1First == p2First) whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\r\t].',			#stamp : 'Anonymous 2/21/2023 22:12',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:13:09.6-05:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t]\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 21:39',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:13',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:13:31.42-05:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\asher\\Documents\\Pharo\\images\\Assignment\\Assignment.image'	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:14:32.664-05:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleCodeCruftLeftInMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleCodeCruftLeftInMethodsRuleV1FalsePositive\r\t^ #()',			#stamp : 'Anonymous 2/21/2023 22:14',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:14:33.427-05:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleCodeCruftLeftInMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleCodeCruftLeftInMethodsRuleV1FalsePositive\r\t^ #()',			#stamp : 'Anonymous 2/21/2023 22:14',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleCodeCruftLeftInMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleCodeCruftLeftInMethodsRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#War #play #false)) #\'2023-02-21T22:14:32.664-05:00\') )',			#stamp : 'Anonymous 2/21/2023 22:14',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:15:34.449-05:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:14',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\tTranscript show: playPlayer1.\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:15',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:18:18.368-05:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\tTranscript show: playPlayer1.\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:15',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:18',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:18:46.448-05:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:18',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:18',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:19:53.859-05:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:18',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1;cr.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:19',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:20:54.802-05:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1;cr.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:19',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1;cr.\r\t\tTranscript show: playPlayer2;cr.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:20',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:22:16.468-05:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1;cr.\r\t\tTranscript show: playPlayer2;cr.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:20',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1;cr.\r\t\tTranscript show: playPlayer2;cr;cr.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:22',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-21T22:25:09.887-05:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: playPlayer1;cr.\r\t\tTranscript show: playPlayer2;cr;cr.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:22',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:25',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T16:17:29.088-05:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r(p1First == p2First) whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\t\r\t].',			#stamp : 'Anonymous 2/21/2023 22:12',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r(p1First == p2First) whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first). \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:17',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T16:28:16.221-05:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/21/2023 22:25',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[^self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 16:28',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T16:30:28.795-05:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r(p1First == p2First) whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first). \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:17',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first). \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:30',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T16:35:18.53-05:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first). \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:30',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first). \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:35',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T16:35:38.301-05:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleCodeCruftLeftInMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleCodeCruftLeftInMethodsRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#War #play #false)) #\'2023-02-21T22:14:32.664-05:00\') )',			#stamp : 'Anonymous 2/21/2023 22:14',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleCodeCruftLeftInMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleCodeCruftLeftInMethodsRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#War #play #false)) #\'2023-02-21T22:14:32.664-05:00\') #(#(#RGMethodDefinition #(#War #war:and: #false)) #\'2023-02-22T16:35:37.336-05:00\') )',			#stamp : 'Anonymous 2/22/2023 16:35',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T16:36:38.549-05:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first). \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:35',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first). \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:36',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T16:38:13.791-05:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first). \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:36',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:38',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T16:39:05.032-05:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:38',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rTranscript show: p1;cr.\rTranscript show: p2;cr.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:39',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T16:51:32.286-05:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[^self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 16:28',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\rTranscript show: playPlayer1; cr.\rTranscript show: playPlayer2; cr.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[^self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 16:51',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T19:53:12.611-05:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rTranscript show: p1;cr.\rTranscript show: p2;cr.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 16:39',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rTranscript show: p1;cr.\rTranscript show: p2;cr.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r"After war ends add the rest to the warchest"\rwarchest add: (p1 first); add: (p2 first).\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 19:53',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T19:56:55.741-05:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\rTranscript show: playPlayer1; cr.\rTranscript show: playPlayer2; cr.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[^self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 16:51',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[^self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 19:56',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:20:35.979-05:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rTranscript show: p1;cr.\rTranscript show: p2;cr.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r"After war ends add the rest to the warchest"\rwarchest add: (p1 first); add: (p2 first).\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 19:53',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rTranscript show: p1;cr.\rTranscript show: p2;cr.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:20',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:27:26.592-05:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\asher\\Documents\\Pharo\\images\\Assignment\\Assignment.image'	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:35:11.784-05:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[^self war: playPlayer1 and: playPlayer2]\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 19:56',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 20:35',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:36:05.361-05:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleEndTrueFalseRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleEndTrueFalseRuleV1FalsePositive\r\t^ #()',			#stamp : 'Anonymous 2/22/2023 20:36',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:36:06.743-05:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleEndTrueFalseRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleEndTrueFalseRuleV1FalsePositive\r\t^ #()',			#stamp : 'Anonymous 2/22/2023 20:36',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestAssignment class',				#isMetaSide : true			},			#name : #ruleEndTrueFalseRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleEndTrueFalseRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#War #play #false)) #\'2023-02-22T20:36:05.362-05:00\') )',			#stamp : 'Anonymous 2/22/2023 20:36',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:47:53.99-05:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 20:35',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 20:47',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:49:03.238-05:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rTranscript show: p1;cr.\rTranscript show: p2;cr.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:20',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:49',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:49:32.547-05:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:49',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:49',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:51:11-05:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:49',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:51',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:51:45.726-05:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tTranscript show: warchest;cr.\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:51',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:51',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:51:53.483-05:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:51',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:51',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T20:53:40.279-05:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1 first); add: (p2 first).\r\r"convert to order collection fro ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:51',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1First); add: (p2First).\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:53',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:02:30.105-05:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1First); add: (p2First).\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 20:53',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1First); add: (p2First).\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\rTranscript show: warchest.\r^warchest',			#stamp : 'Anonymous 2/22/2023 21:02',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:03:53.752-05:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1First); add: (p2First).\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\rTranscript show: warchest.\r^warchest',			#stamp : 'Anonymous 2/22/2023 21:02',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1First); add: (p2First).\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 21:03',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:04:01.243-05:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 20:47',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: warchest.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:04',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:04:16.379-05:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: warchest.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:04',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:04',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:05:11.036-05:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:04',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\tTranscript show: warchest; cr.\r\t\t\t\tTranscript show: playPlayer1;cr.\r\t\t\t\t1 to: ((warchest size)/2) do: [Transcript show: playPlayer2;cr.playPlayer2 removeFirst]\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:05',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:08:53.029-05:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\tTranscript show: warchest; cr.\r\t\t\t\tTranscript show: playPlayer1;cr.\r\t\t\t\t1 to: ((warchest size)/2) do: [Transcript show: playPlayer2;cr.playPlayer2 removeFirst]\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:05',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:08',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:09:00.655-05:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:08',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:09',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:09:44.343-05:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:09',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tTranscript show: (warchest size)/2.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:09',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:10:43.546-05:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tTranscript show: (warchest size)/2.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:09',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tTranscript show: (warchest size)/2.\r\t\t\t\t1 to: ((warchest size)/2) do: [Transcript show:\'HELLO?\'. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:10',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:11:03.565-05:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tTranscript show: (warchest size)/2.\r\t\t\t\t1 to: ((warchest size)/2) do: [Transcript show:\'HELLO?\'. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:10',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tTranscript show: (warchest size)/2.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:11',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:11:06.439-05:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\asher\\Documents\\Pharo\\images\\Assignment\\Assignment.image'	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:20:07.267-05:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tTranscript show: (warchest size)/2.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:11',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:20',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:22:01.174-05:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:20',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[^playPlayer2 asArray] ifFalse:[^playPlayer1 asArray].',			#stamp : 'Anonymous 2/22/2023 21:22',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:22:33.676-05:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[^playPlayer2 asArray] ifFalse:[^playPlayer1 asArray].',			#stamp : 'Anonymous 2/22/2023 21:22',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:22',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:26:28.219-05:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:22',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1]."\r\r\r^1',			#stamp : 'Anonymous 2/22/2023 21:26',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:26:44.688-05:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1]."\r\r\r^1',			#stamp : 'Anonymous 2/22/2023 21:26',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:26',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:28:01.233-05:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:27',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: \'Passed\'.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:28',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:29:37.848-05:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t\tTranscript show: \'Passed\'.\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:28',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\tTranscript show: \'Passed\'.\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:29',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:30:14.077-05:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\tTranscript show: \'Passed\'.\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:29',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: \'Passed\'.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:30',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:31:54.37-05:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: \'Passed\'.\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t]\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:30',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\tTranscript show: \'Passed\'.\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:31',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:33:06.492-05:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\tTranscript show: \'Passed\'.\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:31',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tTranscript show: \'Passed\'.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:33',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:33:37.22-05:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tTranscript show: \'Passed\'.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:33',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a |Transcript show: \'Passed\'. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:33',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:34:58.685-05:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a |Transcript show: \'Passed\'. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:33',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:34',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:36:24.963-05:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:34',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tTranscript show: playPlayer1;cr.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:36',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:37:05.111-05:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tTranscript show: playPlayer1;cr.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:36',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:37',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:37:26.804-05:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:37',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:37',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:38:59.713-05:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1First); add: (p2First).\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 21:03',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1First); add: (p2First).\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\rTranscript show: p1;cr.\r^warchest',			#stamp : 'Anonymous 2/22/2023 21:38',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:39:22.756-05:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\tTranscript show: playPlayer1;cr.\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:37',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:39',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:41:01.684-05:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\rwarchest add: (p1First); add: (p2First).\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\rTranscript show: p1;cr.\r^warchest',			#stamp : 'Anonymous 2/22/2023 21:38',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r"Add the last 2 cards to the warchest and remove the last two cards from the deck"\rwarchest add: (p1First); add: (p2First).\rp1 removeFirst.\rp2 removeFirst.\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 21:41',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:41:10.404-05:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\asher\\Documents\\Pharo\\images\\Assignment\\Assignment.image'	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-22T21:41:33.497-05:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\t1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:39',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #play,			#protocol : #'as yet unclassified',			#sourceCode : 'play \r\r| playPlayer1 playPlayer2 p1First p2First winner warchest|\r\rplayPlayer1 := self getPlayer1.\rplayPlayer2 := self getPlayer2.\rwarchest := OrderedCollection new.\r\r"play the game until one of the decks is empty"\r[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [\r\t\tp1First := playPlayer1 first.\r\t\tp2First := playPlayer2 first.\r\t\t\r\t\twarchest removeAll: warchest.\r\t\t\r\t\t"go into war if two cards match each other"\r\t\t(p1First == p2First) ifTrue:[\r\t\t\twarchest:= self war: playPlayer1 and: playPlayer2.\r\t\t\t\r\t\t\t"Add warchest to player that won and remove cards from loser"\r\t\t\t((warchest last ) == $O) ifTrue:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer1 addAll: warchest.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\twarchest removeLast.\r\t\t\t\tplayPlayer2 addAll: warchest.\r\t\t\t\t].\r\t\t\t]\r\t\t\r\t\tifFalse:[\r\t\t\t((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]\r\t\t\t\tifFalse:[\r\t\t\t\t\tplayPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst\r\t\t\t\t]\r\t\t\t].\r\t].\r\r"Determine who won"\r(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].\r\r^winner asArray',			#stamp : 'Anonymous 2/22/2023 21:41',			#package : #Assignment		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-02-23T00:11:26.379-05:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[p1First == p2First] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r"Add the last 2 cards to the warchest and remove the last two cards from the deck"\rwarchest add: (p1First); add: (p2First).\rp1 removeFirst.\rp2 removeFirst.\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/22/2023 21:41',			#package : #Assignment		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #War,				#isMetaSide : false			},			#name : #'war:and:',			#protocol : #'as yet unclassified',			#sourceCode : 'war: p1 and: p2\r\r| p1First p2First warchest|\r\rp1First := p1 first.\rp2First := p2 first.\r\rwarchest := SortedCollection new.\r\r"changes sorted collection sort from greatest to least"\rwarchest sortBlock:[:a :b | a >= b].\r\r[(p1First == p2First) & ((p1 size) > 3) & ((p2 size) > 3)] whileTrue:[\r\t\twarchest add: p1First; add: p2First. \r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Take face down cards, insert them into the warchest and remove them from the decks"\r\t\twarchest add: (p1 first); add: (p2 first).\r\t\tp1 removeFirst.\r\t\tp2 removeFirst.\r\t\t\r\t\t"Assign to be the third card card comparison"\r\t\tp1First := p1 first.\r\t\tp2First := p2 first.\r\t].\r\r"Add the last 2 cards to the warchest and remove the last two cards from the deck"\rwarchest add: (p1First); add: (p2First).\rp1 removeFirst.\rp2 removeFirst.\r\r"convert to order collection for ease of manipulation" \rwarchest := warchest asOrderedCollection.\r\r"After war ends make sure to move all 1s if they exist to the front"\r[(warchest last) == 1] whileTrue:[\r\twarchest addFirst: 1; removeLast\r].\r\r"After war ends add the bigger value to the warchest and add a character to determine who won"\r"$O for player1, $T for player2"\r(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].\r\r^warchest',			#stamp : 'Anonymous 2/23/2023 00:11',			#package : #Assignment		}	}}