----QUIT----2022-12-05T08:52:59.453604+01:00 Pharo10-SNAPSHOT-64bit-2314c3f.image priorSource: 0!----QUIT----2022-12-05T08:53:28.447671+01:00 Pharo10-SNAPSHOT-64bit-2314c3f.image priorSource: 0!Object subclass: #War	instanceVariableNames: 'deck' 	classVariableNames: ''	package: 'Assignment'!!ManifestAssignment commentStamp: '<historical>' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestAssignment commentStamp: 'Anonymous 2/21/2023 09:35' prior: 33554793!This package contains the Smalltalk assignment for CPS506.!!War commentStamp: 'Anonymous 2/21/2023 09:39' prior: 0!This represents the War class for the game War.This class is responsible for running a game of war. This includes taking in a deck of cards, distrabution of cards and implementing all the necessary rules of the game.!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 09:50'!deal^deck! !War removeSelector: #deal!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 10:04'!deal: deck| obj |obj := self new.obj setdeck: deck.^deck! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 10:04'!setdeck! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 10:05'!setDeck! !War removeSelector: #setdeck!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 10:05' prior: 33555670!deal: deck| obj |obj := self new.obj setDeck: deck.^deck! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 10:07'!setDeck: gameDeckdeck:= gameDeck.! !War removeSelector: #setDeck!Object subclass: #War	instanceVariableNames: 'player_1 player_2'	classVariableNames: ''	package: 'Assignment'!Object subclass: #War	instanceVariableNames: 'player1 player2'	classVariableNames: ''	package: 'Assignment'!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 12:10'!setPlayer1: arrplayer1 := arr.! !War removeSelector: #setDeck:!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 12:11' prior: 33556038!deal: arr| obj deck1 deck2|obj := self new.obj setPlayer1: deck1.^arr! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 12:12'!setPlayer2: arrplayer2 := arr.! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 12:30' prior: 33556717!deal: arr| obj deck1 deck2|obj := self new.deck1 := OrderedCollection new.deck2 := OrderedCollection new.1 to: (arr size) by: 	2 do: [:a | deck1 addLast: (arr at: a). deck2 addLast: (arr at: (a+1))].obj setPlayer1: deck1.obj setPlayer2: deck2.^arr! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 12:34' prior: 33557005!deal: arr| obj deck1 deck2|obj := self new.deck1 := OrderedCollection new.deck2 := OrderedCollection new."deals deck alternating between players and stacking them"1 to: (arr size) by: 	2 do: [:a | deck1 addFirst: (arr at: a). deck2 addFirst: (arr at: (a+1))].obj setPlayer1: deck1.obj setPlayer2: deck2.^arr! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 12:36' prior: 33557366!deal: arr| obj deck1 deck2|obj := self new.deck1 := OrderedCollection new.deck2 := OrderedCollection new."deals deck alternating between players and stack them"1 to: (arr size) by: 	2 do: [:a | deck1 addFirst: (arr at: a). deck2 addFirst: (arr at: (a+1))].obj setPlayer1: deck1.obj setPlayer2: deck2.^arr! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 14:35' prior: 33557788!deal: arr| obj deck1 deck2|obj := self new.deck1 := OrderedCollection new.deck2 := OrderedCollection new."deals deck alternating between players and stack them"1 to: (arr size) by: 	2 do: [:a | deck1 addFirst: (arr at: a). deck2 addFirst: (arr at: (a+1))].obj setPlayer1: deck1.obj setPlayer2: deck2.obj play.^arr! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 14:35'!play ! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 14:37' prior: 33558207!deal: arr| obj deck1 deck2|obj := self new.deck1 := OrderedCollection new.deck2 := OrderedCollection new."deals deck alternating between players and stack them"1 to: (arr size) by: 	2 do: [:a | deck1 addFirst: (arr at: a). deck2 addFirst: (arr at: (a+1))].obj setPlayer1: deck1.obj setPlayer2: deck2.^obj play.! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 14:52' prior: 33558721!deal: arr| obj deck1 deck2|obj := self new.deck1 := OrderedCollection new.deck2 := OrderedCollection new."deals deck alternating between players and stack them"1 to: (arr size) by: 	2 do: [:a | deck1 addFirst: (arr at: a). deck2 addFirst: (arr at: (a+1))].obj setPlayer1: deck1.obj setPlayer2: deck2."return winning deck after playing"^obj play.! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 14:53'!getPlayer1^player1.! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 14:53'!getPlayer2^player2.! !----SNAPSHOT----2023-02-21T15:02:10.804-05:00 Assignment.image priorSource: 99!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 16:14'!war: p1 and: p2! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 16:14' prior: 33558615!play | playPlayer1 playPlayer2 temp p1First p2First|playPlayer1:= self getPlayer1.playPlayer2:= self getPlayer2.temp := OrderedCollection new.[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue:[	temp removeAll: temp.	p1First := playPlayer1 first.	p2First := playPlayer2 first.		(p1First == p2First) ifTrue:[self war: p1First and: p2First ] ifFalse: [].		((p1First  > p2First) & (p2First  ~= 1)) ifTrue: [ playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst] 	ifFalse: [ ].	].! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 16:42' prior: 33559977!play | playPlayer1 playPlayer2 temp p1First p2First|playPlayer1:= self getPlayer1.playPlayer2:= self getPlayer2.temp := OrderedCollection new.[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue:[	temp removeAll: temp.	p1First := playPlayer1 first.	p2First := playPlayer2 first.		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2 ] 	ifFalse: [].		((p1First  > p2First) & (p2First  ~= 1)) ifTrue: [ playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst] 	ifFalse: [ ].	].! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 19:54' prior: 33560612!play | playPlayer1 playPlayer2 warchest p1First p2First|playPlayer1:= self getPlayer1.playPlayer2:= self getPlayer2.warchest := SortedCollection new.[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue:[	warchest removeAll: warchest.	p1First := playPlayer1 first.	p2First := playPlayer2 first.		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2 ] 	ifFalse: [		((p1First == 1) | (p1First  > p2First)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst]		ifFalse:[			playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst			].		].	].(playPlayer1 isEmpty) ifTrue:[^playPlayer2] ifFalse:[^playPlayer1].! !----SNAPSHOT----2023-02-21T20:10:40.674-05:00 Assignment.image priorSource: 5277!----SNAPSHOT----2023-02-21T20:10:43.725-05:00 Assignment.image priorSource: 7552!----SNAPSHOT----2023-02-21T20:10:46.354-05:00 Assignment.image priorSource: 7635!----SNAPSHOT----2023-02-21T20:17:44.513-05:00 Assignment.image priorSource: 7718!----SNAPSHOT----2023-02-21T20:27:41.859-05:00 Assignment.image priorSource: 7801!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 20:28' prior: 33558615!play | playPlayer1 playPlayer2 p1First p2First|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst.]		ifFalse:[			((p2First > p1First) | (p2First == 1)) ifTrue:[playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst.]			]	].(playPlayer1 isEmpty) ifTrue:[^playPlayer2] ifFalse:[^playPlayer1]! !----SNAPSHOT----2023-02-21T20:28:26.365-05:00 Assignment.image priorSource: 7884!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 20:31' prior: 33562491!play | playPlayer1 playPlayer2 p1First p2First|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]		ifFalse:[			((p2First > p1First) | (p2First == 1)) ifTrue:[playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst]			]	].(playPlayer1 isEmpty) ifTrue:[^playPlayer2] ifFalse:[^playPlayer1]! !----SNAPSHOT----2023-02-21T20:31:26.582-05:00 Assignment.image priorSource: 8673!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 20:34' prior: 33563280!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]		ifFalse:[			((p2First > p1First) | (p2First == 1)) ifTrue:[playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst]			]	].(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/21/2023 20:35'!ruleUnclassifiedMethodsRuleV1FalsePositive	^ #()! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/21/2023 20:35' prior: 33564912!ruleUnclassifiedMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #play #false)) #'2023-02-21T20:35:56.233-05:00') )! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/21/2023 20:36'!ruleAssignmentInIfTrueRuleV1FalsePositive	^ #()! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/21/2023 20:36' prior: 33565292!ruleAssignmentInIfTrueRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #play #false)) #'2023-02-21T20:36:07.23-05:00') )! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/21/2023 20:40'!ruleLongMethodsRuleV1FalsePositive	^ #()! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/21/2023 20:40' prior: 33565669!ruleLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #play #false)) #'2023-02-21T20:40:20.973-05:00') )! !----SNAPSHOT----2023-02-21T20:41:21.429-05:00 Assignment.image priorSource: 9510!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 20:42' prior: 33564117!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game while until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]		ifFalse:[				playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst			]	].(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 20:55' prior: 33566118!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game while until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			]	].(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 20:56'!war: p1 and: p2! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 21:39' prior: 33566922!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			]	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 22:12' prior: 33567803!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new.warchest sortBlock:[:a :b | a >= b].(p1First == p2First) whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"			].! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 22:13' prior: 33567913!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !----SNAPSHOT----2023-02-21T22:13:31.357-05:00 Assignment.image priorSource: 11511!!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/21/2023 22:14'!ruleCodeCruftLeftInMethodsRuleV1FalsePositive	^ #()! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/21/2023 22:14' prior: 33570400!ruleCodeCruftLeftInMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #play #false)) #'2023-02-21T22:14:32.664-05:00') )! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 22:14' prior: 33569329!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 22:15' prior: 33570788!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [	Transcript show: playPlayer1.		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 22:18' prior: 33571777!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 22:18' prior: 33572766!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1.	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 22:19' prior: 33573755!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1;cr.	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 22:20' prior: 33574745!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr.	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 22:22' prior: 33575738!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 22:25' prior: 33576766!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 16:17' prior: 33568870!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new.warchest sortBlock:[:a :b | a >= b].(p1First == p2First) whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first). 		p1 removeFirst.		p2 removeFirst.				p1First := p1 first.		p2First := p2 first.	].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 16:28' prior: 33577797!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[^self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 16:30' prior: 33578755!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new.warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first). 		p1 removeFirst.		p2 removeFirst.				p1First := p1 first.		p2First := p2 first.	].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 16:35' prior: 33580312!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new.warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		Transcript show: warchest.		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first). 		p1 removeFirst.		p2 removeFirst.				p1First := p1 first.		p2First := p2 first.	].^warchest! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/22/2023 16:35' prior: 33570561!ruleCodeCruftLeftInMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #play #false)) #'2023-02-21T22:14:32.664-05:00') #(#(#RGMethodDefinition #(#War #war:and: #false)) #'2023-02-22T16:35:37.336-05:00') )! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 16:36' prior: 33580910!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new.warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first). 		p1 removeFirst.		p2 removeFirst.				p1First := p1 first.		p2First := p2 first.	].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 16:38' prior: 33581862!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new.warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.				p1First := p1 first.		p2First := p2 first.	].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 16:39' prior: 33582492!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.Transcript show: p1;cr.Transcript show: p2;cr.warchest := SortedCollection new.warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.				p1First := p1 first.		p2First := p2 first.	].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 16:51' prior: 33579353!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.Transcript show: playPlayer1; cr.Transcript show: playPlayer2; cr."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[^self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 19:53' prior: 33583153!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.Transcript show: p1;cr.Transcript show: p2;cr.warchest := SortedCollection new.warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	]."After war ends add the rest to the warchest"warchest add: (p1 first); add: (p2 first).^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 19:56' prior: 33583863!play | playPlayer1 playPlayer2 p1First p2First winner|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[^self war: playPlayer1 and: playPlayer2]		ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 20:20' prior: 33584891!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.Transcript show: p1;cr.Transcript show: p2;cr.warchest := SortedCollection new.warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	].warchest add: (p1 first); add: (p2 first)."convert to order collection fro ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-22T20:27:26.441-05:00 Assignment.image priorSource: 15794!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 20:35' prior: 33585739!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/22/2023 20:36'!ruleEndTrueFalseRuleV1FalsePositive	^ #()! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/22/2023 20:36' prior: 33589426!ruleEndTrueFalseRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #play #false)) #'2023-02-22T20:36:05.362-05:00') )! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 20:47' prior: 33588038!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 20:49' prior: 33586698!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new.warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	].warchest add: (p1 first); add: (p2 first)."convert to order collection fro ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 20:49' prior: 33591223!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	].warchest add: (p1 first); add: (p2 first)."convert to order collection fro ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 20:51' prior: 33592430!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		Transcript show: warchest;cr.		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	].warchest add: (p1 first); add: (p2 first)."convert to order collection fro ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 20:51' prior: 33593693!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.		"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	].warchest add: (p1 first); add: (p2 first)."convert to order collection fro ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 20:51' prior: 33594924!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	].warchest add: (p1 first); add: (p2 first)."convert to order collection fro ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 20:53' prior: 33596123!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	].warchest add: (p1First); add: (p2First)."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:02' prior: 33597325!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	].warchest add: (p1First); add: (p2First)."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].Transcript show: warchest.^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:03' prior: 33598525!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	].warchest add: (p1First); add: (p2First)."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:04' prior: 33589794!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.			Transcript show: warchest.			"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:04' prior: 33600952!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				1 to: ((warchest size)/2) do: [playPlayer2 removeFirst]				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:05' prior: 33602407!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				Transcript show: warchest; cr.				Transcript show: playPlayer1;cr.				1 to: ((warchest size)/2) do: [Transcript show: playPlayer2;cr.playPlayer2 removeFirst]				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst]				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:08' prior: 33603836!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:09' prior: 33605369!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:09' prior: 33606883!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				Transcript show: (warchest size)/2.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:10' prior: 33608363!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				Transcript show: (warchest size)/2.				1 to: ((warchest size)/2) do: [Transcript show:'HELLO?'. playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:11' prior: 33609883!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				Transcript show: (warchest size)/2.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !----SNAPSHOT----2023-02-22T21:11:06.387-05:00 Assignment.image priorSource: 33430!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:20' prior: 33611429!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:22' prior: 33613033!play | playPlayer1 playPlayer2 p1First p2First warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[^playPlayer2 asArray] ifFalse:[^playPlayer1 asArray].! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:22' prior: 33614523!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:26' prior: 33615987!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won""(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1]."^1! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:26' prior: 33617477!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:27' prior: 33618957!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:28' prior: 33620447!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: 'Passed'.	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:29' prior: 33621937!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				].			Transcript show: 'Passed'.			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:30' prior: 33623456!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.			Transcript show: 'Passed'.			"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst.playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				]			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:31' prior: 33624977!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				].			Transcript show: 'Passed'.			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:33' prior: 33626493!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				Transcript show: 'Passed'.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:33' prior: 33628015!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a |Transcript show: 'Passed'. playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:34' prior: 33629538!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:36' prior: 33631056!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				Transcript show: playPlayer1;cr.				1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:37' prior: 33632613!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.			Transcript show: playPlayer1;cr.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:37' prior: 33634207!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			Transcript show: playPlayer1;cr.			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a |Transcript show: playPlayer1;cr. Transcript show: playPlayer2;cr. playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:38' prior: 33599752!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	].warchest add: (p1First); add: (p2First)."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].Transcript show: p1;cr.^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:39' prior: 33635800!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				1 to: ((warchest size)/2) do: [:a | playPlayer1 removeFirst. playPlayer2 removeFirst].				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:41' prior: 33637393!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[p1First == p2First] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	]."Add the last 2 cards to the warchest and remove the last two cards from the deck"warchest add: (p1First); add: (p2First).p1 removeFirst.p2 removeFirst."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-22T21:41:10.364-05:00 Assignment.image priorSource: 58425!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/22/2023 21:41' prior: 33638616!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 00:11' prior: 33640108!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First) & ((p1 size) > 3) & ((p2 size) > 3)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				"Take face down cards, insert them into the warchest and remove them from the decks"		warchest add: (p1 first); add: (p2 first).		p1 removeFirst.		p2 removeFirst.				"Assign to be the third card card comparison"		p1First := p1 first.		p2First := p2 first.	]."Add the last 2 cards to the warchest and remove the last two cards from the deck"warchest add: (p1First); add: (p2First).p1 removeFirst.p2 removeFirst."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 00:14' prior: 33638616!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !----SNAPSHOT----2023-02-23T00:15:35.433-05:00 Assignment.image priorSource: 86899!----SNAPSHOT----2023-02-23T08:17:03.035-05:00 Assignment.image priorSource: 90956!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:17' prior: 33640108!war: p1 and: p2| p1First p2First warchest break|p1First := p1 first.p2First := p2 first.break := 1.warchest := SortedCollection new."changes sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First) & (break == 1)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[break = 0] 		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.						"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.			].	]."Add the last 2 cards to the warchest and remove the last two cards from the deck"warchest add: (p1First); add: (p2First).p1 removeFirst.p2 removeFirst."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:22' prior: 33645648!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].! !----SNAPSHOT----2023-02-23T08:36:11.518-05:00 Assignment.image priorSource: 91040!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:44' prior: 33647088!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-23T08:44:58.419-05:00 Assignment.image priorSource: 92877!----SNAPSHOT----2023-02-23T08:47:05.146-05:00 Assignment.image priorSource: 94432!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:47' prior: 33647485!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:52' prior: 33649124!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) > 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:52' prior: 33650597!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:52' prior: 33652069!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:53' prior: 33653542!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].		Transcript show: 'Here'.	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:54' prior: 33655015!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.			].		Transcript show: 'Here'.	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:54' prior: 33656515!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].		Transcript show: 'Here'.	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 08:54' prior: 33657880!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"Transcript show: 'Here'.((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:06' prior: 33659380!war: p1 and: p2| p1First p2First warchest |p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:10' prior: 33660878!war: p1 and: p2| p1First p2First warchest counter|p1First := p1 first.p2First := p2 first.counter := 0.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		counter := counter + 1.		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].		Transcript show: counter.	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:10' prior: 33662351!war: p1 and: p2| p1First p2First warchest counter|p1First := p1 first.p2First := p2 first.counter := 0.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		counter := counter + 1.		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].		Transcript show: counter;cr.	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:13' prior: 33663899!war: p1 and: p2| p1First p2First warchest counter|p1First := p1 first.p2First := p2 first.counter := 0.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		counter := counter + 1.		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].		Transcript show: counter;cr.	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:14' prior: 33665450!war: p1 and: p2| p1First p2First warchest counter|p1First := p1 first.p2First := p2 first.counter := 0.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		counter := counter + 1.		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].		Transcript show: p1;cr.	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:15' prior: 33667001!war: p1 and: p2| p1First p2First warchest counter|p1First := p1 first.p2First := p2 first.counter := 0.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		counter := counter + 1.		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].		Transcript show: p1;cr.	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:15' prior: 33668547!war: p1 and: p2| p1First p2First warchest counter|p1First := p1 first.p2First := p2 first.counter := 0.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		counter := counter + 1.		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[Transcript show: 'Here'.warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:15' prior: 33670061!war: p1 and: p2| p1First p2First warchest counter|p1First := p1 first.p2First := p2 first.counter := 0.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		counter := counter + 1.		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. Transcript show: 'Here'.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:16' prior: 33671605!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	].Transcript show: 'Here'."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:17' prior: 33673150!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[				(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.								"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	].Transcript show: 'Here'."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-23T09:17:35.598-05:00 Assignment.image priorSource: 94516!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:18' prior: 33674646!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		warchest add: p1First; add: p2First. 		p1 removeFirst.		p2 removeFirst.				(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]		ifFalse:[				"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	].Transcript show: 'Here'."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:22' prior: 33676236!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	].Transcript show: 'Here'."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:22' prior: 33677732!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-23T09:22:41.1-05:00 Assignment.image priorSource: 121628!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:23' prior: 33679248!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:23' prior: 33680823!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:24' prior: 33682431!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:24' prior: 33684039!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:25' prior: 33685647!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].Transcript show: warchest.^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:25' prior: 33687255!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].Transcript show: warchest; cr.^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:28' prior: 33688889!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 2) | ((p2 size) < 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].Transcript show: warchest; cr.^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:28' prior: 33690527!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].Transcript show: warchest; cr.^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:29' prior: 33692165!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].Transcript show: p1; cr.^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:30' prior: 33693803!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:31' prior: 33644170!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1.	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:31' prior: 33697043!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1;cr.	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:33' prior: 33698385!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer2;cr.	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:34' prior: 33699730!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:39' prior: 33695435!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 3)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 09:40' prior: 33702385!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 10:39' prior: 33701075!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.			Transcript show: warchest;cr.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 10:40' prior: 33705466!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			Transcript show: p1First;cr.			warchest:= self war: playPlayer1 and: playPlayer2.			Transcript show: p1First;cr;cr.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !----SNAPSHOT----2023-02-23T10:41:05.233-05:00 Assignment.image priorSource: 126216!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 10:41' prior: 33706809!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			Transcript show: p1First;cr.			Transcript show: p2First;cr;cr.			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 10:42' prior: 33703858!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) <= 2) | ((p2 size) <= 2)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 10:45' prior: 33708271!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 10:46' prior: 33709648!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.												Transcript show: p1First;cr.						Transcript show: p2First;cr;cr.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 11:04' prior: 33712568!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.												Transcript show: p1First;cr.						Transcript show: p2First.					] 			].	].Transcript show: 'Out';cr;cr."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 11:06' prior: 33714256!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := 14]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/23/2023 11:06' prior: 33711258!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		Transcript show: p1First;cr.		Transcript show: p2First;cr;cr.		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !----SNAPSHOT----2023-02-23T11:08:41.497-05:00 Assignment.image priorSource: 153662!----QUIT----2023-02-23T16:47:20.415-05:00 Assignment.image priorSource: 164426!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 14:23' prior: 33715967!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move everything to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := -1]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 14:34' prior: 33717575!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1 	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 14:34' prior: 33720724!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].		Transcript show: playPlayer1;cr.	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 14:36' prior: 33722066!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 14:40' prior: 33723411!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer2;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 14:42' prior: 33724756!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer2.playPlayer2 := self getPlayer1.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer2;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 14:47' prior: 33726101!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 14:48' prior: 33727446!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer2;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 14:48' prior: 33728756!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 16:54' prior: 33730101!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			((p1First > p2First) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:00' prior: 33731411!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			(((p1First > p2First) & (p1First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:00' prior: 33732756!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			(((p1First > p2First) & (p1First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:00' prior: 33734120!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			(((p1First > p2First) & (p1First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:02' prior: 33735449!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:02' prior: 33736813!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !----SNAPSHOT----2023-02-24T17:13:15.442-05:00 Assignment.image priorSource: 164511!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:13' prior: 33738177!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !----SNAPSHOT----2023-02-24T17:13:45.239-05:00 Assignment.image priorSource: 184982!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:14' prior: 33739591!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:35' prior: 33741046!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer2;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:36' prior: 33742451!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: playPlayer2;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:37' prior: 33743856!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: playPlayer1;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:37' prior: 33745258!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: playPlayer2;cr.^winner asArray! !----SNAPSHOT----2023-02-24T17:41:08.437-05:00 Assignment.image priorSource: 186437!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:44' prior: 33719116!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			((p1 size) < (p2 size)) ifTrue:[warchest addAll: p1; add: p2First. p1First := -1. p1 removeAll]. 			((p1 size) > (p2 size)) ifTrue:[warchest addAll: p2; add: p1First. p2First := -1. p2 removeAll]. 			 ]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:44' prior: 33748147!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			((p1 size) < (p2 size)) ifTrue:[warchest addAll: p1; add: p2First. 				p1First := -1. p1 removeAll]. 			((p1 size) > (p2 size)) ifTrue:[warchest addAll: p2; add: p1First. 				p2First := -1. p2 removeAll]. 			 ]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:54' prior: 33719116!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Player1's deck runs out during war"			((p1 size) < (p2 size)) ifTrue:[				1 to: (p1 size) do: [:a | warchest add:p1 first; add: p2 first. 					p1 removeFirst. p2 removeFirst].										"So we can know p1 lost"					p1First := -1				].						"Player2's deck runs out during war"			((p1 size) > (p2 size)) ifTrue:[				1 to: (p1 size) do: [:a | warchest add:p1 first; add: p2 first. 					p1 removeFirst. p2 removeFirst].										"So we can know p1 lost"					p1First := -1				].			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 17:55' prior: 33751663!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Player1's deck runs out during war"			((p1 size) < (p2 size)) ifTrue:[				1 to: (p1 size) do: [:a | warchest add:p1 first; add: p2 first. 					p1 removeFirst. p2 removeFirst].										"So we can know p1 lost"					p1First := -1				].						"Player2's deck runs out during war"			((p1 size) > (p2 size)) ifTrue:[				1 to: (p2 size) do: [:a | warchest add:p1 first; add: p2 first. 					p1 removeFirst. p2 removeFirst].										"So we can know p2 lost"					p2First := -1				].			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:08' prior: 33719116!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Player 1 runs out of cards during war"			((p1 size) < (p2 size)) ifTrue:[				1 to: (p1 size) do: [:a | warchest add: p1 first; add: p2 first. p1 removeFirst].								"Show that player 1 lost"				p1First := -1.				].			warchest addAll: p1. 			warchest addAll: p2. 			p1 removeAll. p2 removeAll. ]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:08' prior: 33755751!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Player 1 runs out of cards during war"			((p1 size) < (p2 size)) ifTrue:[				1 to: (p1 size) do: [:a | warchest add: p1 first; add: p2 first. p1 removeFirst].								"Show that player 1 lost"				p1First := -1				].			warchest addAll: p1. 			warchest addAll: p2. 			p1 removeAll. p2 removeAll. ]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-24T18:10:25.931-05:00 Assignment.image priorSource: 193538!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:10' prior: 33757605!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Player 1 runs out of cards during war"			((p1 size) < (p2 size)) ifTrue:[				1 to: (p1 size) do: [:a | warchest add: p1 first; add: p2 first. p1 removeFirst. p2 removeFirst].								"Show that player 1 lost"				p1First := -1				].			"Player 1 runs out of cards during war"			((p1 size) > (p2 size)) ifTrue:[				1 to: (p2 size) do: [:a | warchest add: p1 first; add: p2 first. p1 removeFirst. p2 removeFirst].								"Show that player 2 lost"				p2First := -1				].			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:13' prior: 33757605!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Player 1 runs out of cards during war"			((p1 size) < (p2 size)) ifTrue:[				Transcript show: 'Player 1 short';cr.				].			"Player 1 runs out of cards during war"			((p1 size) > (p2 size)) ifTrue:[				Transcript show: 'Player 2 short';cr.				].			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:14' prior: 33757605!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Player 1 runs out of cards during war"			((p1 size) < (p2 size)) ifTrue:[					Transcript show: 'Player 1 short';cr.					p1 removeAll.				].			"Player 1 runs out of cards during war"			((p1 size) > (p2 size)) ifTrue:[					Transcript show: 'Player 2 short';cr.					p2 removeAll.				].			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:15' prior: 33757605!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Player 1 runs out of cards during war"			((p1 size) < (p2 size)) ifTrue:[				1 to: (p1 size) do: [:a | warchest add: p1 first; add: p2 first. p1 removeFirst. p2 removeFirst].				Transcript show: 'Player 1 short';cr.				p1 removeAll.				^warchest				].			"Player 1 runs out of cards during war"			((p1 size) > (p2 size)) ifTrue:[				Transcript show: 'Player 2 short';cr.				p2 removeAll.				^warchest				].			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:18' prior: 33765227!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Player 1 runs out of cards during war"			((p1 size) < (p2 size)) ifTrue:[				Transcript show: 'Player 1 short';cr.				p1 removeAll.				^warchest				].			"Player 1 runs out of cards during war"			((p1 size) > (p2 size)) ifTrue:[				Transcript show: 'Player 2 short';cr.				p2 removeAll.				^warchest				].			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"((p1First > p2First) & ((p1 size) >= 2)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:39' prior: 33757605!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"player 1 runs out of cards during war"			((p1 size) < (p2 size)) ifTrue:[					1 to: (p1 size) do: [warchest add: p1 first; add: p2 first. 						p1 removeFirst. p2 removeFirst].										"Indicates player 1 lost"					p1First := -1.				].						"player 2 runs out of cards during war"			((p1 size) > (p2 size)) ifTrue:[					1 to: (p2 size) do: [warchest add: p1 first; add: p2 first. 						p1 removeFirst. p2 removeFirst].										"Indicates player 2 lost"					p2First := -1.				].		 ]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-24T18:39:35.464-05:00 Assignment.image priorSource: 204934!----SNAPSHOT----2023-02-24T18:43:09.284-05:00 Assignment.image priorSource: 216574!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:46' prior: 33746660!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:50' prior: 33746660!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new.^playPlayer1 asArray! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/24/2023 18:50'!ruleReTemporaryNeitherReadNorWrittenRuleV1FalsePositive	^ #()! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/24/2023 18:50' prior: 33772919!ruleReTemporaryNeitherReadNorWrittenRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #play #false)) #'2023-02-24T18:50:15.137-05:00') )! !----QUIT/NOSAVE----2023-02-24T18:51:09.71-05:00 Assignment.image priorSource: 216659!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:51' prior: 33746660!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new.^playPlayer2  asArray! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/24/2023 18:52'!ruleReTemporaryNeitherReadNorWrittenRuleV1FalsePositive	^ #()! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/24/2023 18:52' prior: 33773695!ruleReTemporaryNeitherReadNorWrittenRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #play #false)) #'2023-02-24T18:52:04.362-05:00') )! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:52' prior: 33773414!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new.Transcript show: 'a'."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: playPlayer2;cr.^winner asArray! !----QUIT/NOSAVE----2023-02-24T18:55:51.011-05:00 Assignment.image priorSource: 216659!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:57' prior: 33769069!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			warchest addAll: p1. warchest addAll: p2. p1 removeAll. p2 removeAll. p1First := -1		 ]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:58' prior: 33775615!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: 			p2. p1 removeAll. p2 removeAll. p1First := -1]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-24T18:58:17.434-05:00 Assignment.image priorSource: 216659!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:01' prior: 33777231!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := -1]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-24T19:02:26.21-05:00 Assignment.image priorSource: 224319!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:13' prior: 33778928!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[				((p1 size) < (p2 size)) ifTrue:[						1 to: (p1 size) do:[warchest add: p1 first. warchest add: p2 first. 						p1 removeFirst. p2 removeFirst].											p1First := -1					]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:17' prior: 33778928!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := -1. Transcript show: 'Hi';cr.			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:21' prior: 33782337!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[				((p1 size) < (p2 size)) ifTrue:[warchest add: p1 first. warchest add: p2 first. 			p1 removeFirst. p2 removeFirst. p1First := -1]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:23' prior: 33778928!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[				((p1 size) < (p2 size)) ifTrue:[					warchest add: (p1 first). warchest add: (p2 first). p1 removeFirst. p2 removeFirst. p1First := -1					]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:26' prior: 33778928!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[				((p1 size) <= (p2 size)) ifTrue:[warchest add: (p1 first). warchest add: (p2 first). 			p1 removeFirst. p2 removeFirst. p1First := -1]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:45' prior: 33778928!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest add: (p1 first). warchest add: (p2 first). 			p1 removeAll. p2 removeAll. p1First := -1]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:46' prior: 33788989!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest add: (p1 first). warchest add: (p2 first). 			p1 removeFirst. p2 removeFirst. p1First := -1]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:49' prior: 33778928!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[warchest add: (p1 first). warchest add: (p2 first).			p1 removeFirst. p2 removeFirst.]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:54' prior: 33792235!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[				((p1 size) == (p2 size)) ifTrue:[warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll.]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:56' prior: 33778928!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			((p1 size) == (p2 size)) ifTrue: [warchest addAll: p1. warchest addAll: p2. 			p1 removeAll. p2 removeAll. p1First := -1]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 20:01' prior: 33795487!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			((p1 size) == (p2 size)) ifTrue: [					1 to: (p1 size) do: [warchest addAll: p1. warchest addAll: p2. 						p1 removeAll. p2 removeAll].					p1First := -1 				]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 20:02' prior: 33797142!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			((p1 size) == (p2 size)) ifTrue: [					1 to: (p1 size) do: [:a | warchest addAll: p1. warchest addAll: p2. 						p1 removeAll. p2 removeAll].					p1First := -1 				]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 20:05' prior: 33798839!war: p1 and: p2| p1First p2First warchest|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			((p1 size) == (p2 size)) ifTrue: [					1 to: (p1 size) do: [:a | warchest add: (p1 first). warchest add: (p2 first). 						p1 removeAll. p2 removeAll].					p1First := -1 				]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 20:37' prior: 33800541!war: p1 and: p2| p1First p2First warchest size|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			((p1 size) < (p2 size)) ifTrue:[size := (p1 size). p1First := -1] 				ifFalse:[size := (p2 size). p2First := -1].							1 to: size do: [:a | warchest add: (p1 first). warchest add: (p2 first). 					p1 removeFirst. p2 removeFirst]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-24T20:38:06.375-05:00 Assignment.image priorSource: 226016!----SNAPSHOT----2023-02-24T20:40:09.696-05:00 Assignment.image priorSource: 249500!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 20:41' prior: 33802253!war: p1 and: p2| p1First p2First warchest size|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Figure out which one is smaller and change the first to exit the loop"			"and indicate who lost"			((p1 size) < (p2 size)) ifTrue:[size := (p1 size). p1First := -1] 				ifFalse:[size := (p2 size). p2First := -1].							1 to: size do: [:a | warchest add: (p1 first). warchest add: (p2 first). 					p1 removeFirst. p2 removeFirst]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends add the bigger value to the warchest and add a character to determine who won""$O for player1, $T for player2"(p1First > p2First) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/24/2023 20:41'!ruleUtilityMethodsRuleV1FalsePositive	^ #()! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/24/2023 20:41' prior: 33806065!ruleUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #war:and: #false)) #'2023-02-24T20:41:45.957-05:00') )! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/24/2023 20:41' prior: 33565070!ruleUnclassifiedMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #play #false)) #'2023-02-21T20:35:56.233-05:00') #(#(#RGMethodDefinition #(#War #war:and: #false)) #'2023-02-24T20:41:50.385-05:00') )! !!ManifestAssignment class methodsFor: 'code-critics' stamp: 'Anonymous 2/24/2023 20:41' prior: 33565819!ruleLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#War #play #false)) #'2023-02-21T20:40:20.973-05:00') #(#(#RGMethodDefinition #(#War #war:and: #false)) #'2023-02-24T20:41:53.774-05:00') )! !----SNAPSHOT----2023-02-24T20:41:58.083-05:00 Assignment.image priorSource: 249585!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 20:42' prior: 33746660!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: playPlayer1;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 20:47' prior: 33807162!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 21:50' prior: 33808564!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 22:36' prior: 33809969!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 22:39' prior: 33811414!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: playPlayer2.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 22:40' prior: 33812786!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: playPlayer2;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 22:55' prior: 33814187!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !----SNAPSHOT----2023-02-24T23:43:42.549-05:00 Assignment.image priorSource: 252553!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:00' prior: 33815591!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					(((p1First < p2First) & (p1First ~= 1)) | (p2First == 1)) ifTrue:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst]				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:00' prior: 33817075!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					(((p1First < p2First) & (p1First ~= 1)) | (p2First == 1)) ifTrue:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst]				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:00' prior: 33818547!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. 					playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:02' prior: 33820019!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. 																										playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. 					playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:02' prior: 33821424!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[					playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. 					playPlayer1 removeFirst. playPlayer2 removeFirst				]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. 					playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:14' prior: 33822856!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.			Transcript show: playPlayer1;cr.			Transcript show: playPlayer2;cr.			"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[					playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. 					playPlayer1 removeFirst. playPlayer2 removeFirst				]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. 					playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:16' prior: 33824278!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.			Transcript show: playPlayer1;cr.			Transcript show: playPlayer2;cr;cr.			"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[					playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. 					playPlayer1 removeFirst. playPlayer2 removeFirst				]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. 					playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:16' prior: 33825768!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			Transcript show: playPlayer1;cr.			Transcript show: playPlayer2;cr;cr.			warchest:= self war: playPlayer1 and: playPlayer2.			"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[					playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. 					playPlayer1 removeFirst. playPlayer2 removeFirst				]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. 					playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:20' prior: 33827261!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			Transcript show: playPlayer1;cr.			Transcript show: playPlayer2;cr.			warchest:= self war: playPlayer1 and: playPlayer2.						Transcript show: warchest;cr;cr.			"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[					playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. 					playPlayer1 removeFirst. playPlayer2 removeFirst				]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. 					playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:24' prior: 33828754!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.		"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.			"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[					playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. 					playPlayer1 removeFirst. playPlayer2 removeFirst				]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. 					playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:33' prior: 33815591!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.				Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:35' prior: 33815591!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 09:49' prior: 33815591!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 10:53' prior: 33815591!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.				"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 10:56' prior: 33815591!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.		"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 10:57' prior: 33815591!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr.			"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 12:27' prior: 33815591!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.		"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !----QUIT/NOSAVE----2023-02-25T16:19:44.46-05:00 Assignment.image priorSource: 262466!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 16:22' prior: 33815591!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 17:42' prior: 33804194!war: p1 and: p2| p1First p2First warchest size|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Figure out which one is smaller and change the first to exit the loop"			"and indicate who lost"			((p1 size) < (p2 size)) ifTrue:[size := (p1 size). p1First := -1] 				ifFalse:[size := (p2 size). p2First := -1].							1 to: size do: [:a | warchest add: (p1 first). warchest add: (p2 first). 					p1 removeFirst. p2 removeFirst]			]		ifFalse:[				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign to be the third card card comparison"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends determine who won by the last card dropped""$O for player1, $T for player2"(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 17:42' prior: 33842145!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !----SNAPSHOT----2023-02-25T17:43:10.442-05:00 Assignment.image priorSource: 262466!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 17:43' prior: 33845493!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !----QUIT/NOSAVE----2023-02-25T17:43:40.733-05:00 Assignment.image priorSource: 292368!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 17:45' prior: 33845493!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !----SNAPSHOT----2023-02-25T17:47:53.851-05:00 Assignment.image priorSource: 292368!----SNAPSHOT----2023-02-25T17:50:04.675-05:00 Assignment.image priorSource: 295285!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 17:50' prior: 33848437!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 18:46' prior: 33849979!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 18:49' prior: 33851451!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.		Transcript show: playPlayer1;cr.		Transcript show: playPlayer2;cr;cr.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].Transcript show: winner;cr.^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 19:17' prior: 33852850!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 19:18' prior: 33854322!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			"O for player1 adnd T for player2"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 19:19' prior: 33855694!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"reset wwarchest"		warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			"O for player1 adnd T for player2"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 19:22' prior: 33843617!war: p1 and: p2| p1First p2First warchest size|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Figure out which one is smaller and change the first to exit the loop"			"and indicate who lost"			((p1 size) < (p2 size)) ifTrue:[size := (p1 size). p1First := -1] 				ifFalse:[size := (p2 size). p2First := -1].							1 to: size do: [:a | warchest add: (p1 first). warchest add: (p2 first). 					p1 removeFirst. p2 removeFirst]			]		ifFalse:[				"Add inital war cards to the warchest"				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign the firsts to be the third cards and compare them"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends determine who won by the last card dropped""$O for player1, $T for player2"(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !----SNAPSHOT----2023-02-25T19:22:15.628-05:00 Assignment.image priorSource: 295370!----SNAPSHOT----2023-02-25T19:27:29.733-05:00 Assignment.image priorSource: 305942!----QUIT----2023-02-25T19:28:20.288-05:00 Assignment.image priorSource: 306027!----QUIT/NOSAVE----2023-02-25T19:33:04.143-05:00 Assignment.image priorSource: 306112!