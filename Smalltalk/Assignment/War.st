'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 25 February 2023 at 7:29:40.906 pm'!Object subclass: #War	instanceVariableNames: 'player1 player2'	classVariableNames: ''	package: 'Assignment'!!War commentStamp: 'Anonymous 2/21/2023 09:39' prior: 0!This represents the War class for the game War.This class is responsible for running a game of war. This includes taking in a deck of cards, distrabution of cards and implementing all the necessary rules of the game.!!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 19:22'!war: p1 and: p2| p1First p2First warchest size|p1First := p1 first.p2First := p2 first.warchest := SortedCollection new."change sorted collection sort from greatest to least"warchest sortBlock:[:a :b | a >= b].[(p1First == p2First)] whileTrue:[		"Check to see if one of the players will have an empty hand during war"		"If so move the remaining from the smaller deck to the warchest"		(((p1 size) < 3) | ((p2 size) < 3)) ifTrue:[			"Figure out which one is smaller and change the first to exit the loop"			"and indicate who lost"			((p1 size) < (p2 size)) ifTrue:[size := (p1 size). p1First := -1] 				ifFalse:[size := (p2 size). p2First := -1].							1 to: size do: [:a | warchest add: (p1 first). warchest add: (p2 first). 					p1 removeFirst. p2 removeFirst]			]		ifFalse:[				"Add inital war cards to the warchest"				warchest add: p1First; add: p2First. 				p1 removeFirst.				p2 removeFirst.						"Take face down cards, insert them into the warchest and remove them from the decks"				warchest add: (p1 first); add: (p2 first).				p1 removeFirst.				p2 removeFirst.								"Assign the firsts to be the third cards and compare them"				p1First := p1 first.				p2First := p2 first.								(p1First ~= p2First) ifTrue:[						warchest add: p1First; add: p2First. 						p1 removeFirst.						p2 removeFirst.					] 			].	]."convert to order collection for ease of manipulation" warchest := warchest asOrderedCollection."After war ends make sure to move all 1s if they exist to the front"[(warchest last) == 1] whileTrue:[	warchest addFirst: 1; removeLast]."After war ends determine who won by the last card dropped""$O for player1, $T for player2"(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue: [warchest addLast: $O] 	ifFalse: [warchest addLast: $T].^warchest! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 12:12'!setPlayer2: arrplayer2 := arr.! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 14:53'!getPlayer2^player2.! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/25/2023 19:19'!play | playPlayer1 playPlayer2 p1First p2First winner warchest|playPlayer1 := self getPlayer1.playPlayer2 := self getPlayer2.warchest := OrderedCollection new."play the game until one of the decks is empty"[ (playPlayer1 isNotEmpty) & (playPlayer2 isNotEmpty) ] whileTrue: [		p1First := playPlayer1 first.		p2First := playPlayer2 first.				"reset wwarchest"		warchest removeAll: warchest.						"go into war if two cards match each other"		(p1First == p2First) ifTrue:[			warchest:= self war: playPlayer1 and: playPlayer2.						"Add warchest to player that won and remove cards from loser"			"O for player1 adnd T for player2"			((warchest last ) == $O) ifTrue:[				warchest removeLast.				playPlayer1 addAll: warchest.				]			ifFalse:[				warchest removeLast.				playPlayer2 addAll: warchest.				].			]				ifFalse:[			"Make sure 1s are the highest number"			(((p1First > p2First) & (p2First ~= 1)) | (p1First == 1)) ifTrue:[playPlayer1 addLast: p1First. playPlayer1 addLast: p2First. playPlayer1 removeFirst. playPlayer2 removeFirst]				ifFalse:[					playPlayer2 addLast: p2First. playPlayer2 addLast: p1First. playPlayer2 removeFirst. playPlayer1 removeFirst				]			].	]."Determine who won"(playPlayer1 isEmpty) ifTrue:[winner := playPlayer2] ifFalse:[winner := playPlayer1].^winner asArray! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 12:10'!setPlayer1: arrplayer1 := arr.! !!War methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 14:53'!getPlayer1^player1.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!War class	instanceVariableNames: ''!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/21/2023 14:52'!deal: arr| obj deck1 deck2|obj := self new.deck1 := OrderedCollection new.deck2 := OrderedCollection new."deals deck alternating between players and stack them"1 to: (arr size) by: 	2 do: [:a | deck1 addFirst: (arr at: a). deck2 addFirst: (arr at: (a+1))].obj setPlayer1: deck1.obj setPlayer2: deck2."return winning deck after playing"^obj play.! !